# Modan2 통합 리팩토링 및 테스트 계획

## 작성일: 2025-08-29

## 1. 개요

### 1.1 현재 상황
- `Modan2.py`: 1500줄의 모놀리식 구조로 UI, 비즈니스 로직, 데이터 처리가 혼재
- 테스트: 비즈니스 로직 위주의 단위 테스트만 존재, UI 테스트 부재
- 의존성: NumPy 2.0+ 호환성 확보 완료

### 1.2 목표
- **단기 목표**: UI 테스트 안전망 구축으로 리팩토링 리스크 최소화
- **중기 목표**: MVC 패턴 적용으로 코드 구조 개선
- **장기 목표**: 유지보수성, 테스트 가능성, 확장성이 뛰어난 아키텍처 구축

### 1.3 핵심 원칙
1. **점진적 개선**: 한 번에 하나씩, 작은 단위로 변경
2. **테스트 우선**: 변경 전 테스트 작성, 변경 후 테스트 통과 확인
3. **기능 보존**: 사용자 경험에 영향 없이 내부 구조만 개선
4. **지속적 검증**: 매 단계마다 앱 실행 및 자동화 테스트 실행

---

## 2. 사전 준비 단계

### 2.1 개발 환경 설정
```bash
# 테스트 의존성 설치
pip install pytest-qt pytest-cov pytest-mock

# 개발 의존성 설치
pip install ruff mypy
```

### 2.2 테스트 인프라 구축
```python
# tests/conftest.py 확장
import pytest
import tempfile
import shutil
from unittest.mock import MagicMock
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt

@pytest.fixture(scope='session')
def qapp():
    """Global Qt Application fixture"""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app
    app.quit()

@pytest.fixture
def temp_db(tmp_path):
    """Temporary database for testing"""
    db_path = tmp_path / "test_modan.db"
    return str(db_path)

@pytest.fixture
def mock_database(monkeypatch, temp_db):
    """Mock database operations"""
    import MdModel
    monkeypatch.setattr(MdModel, 'DATABASE_PATH', temp_db)
    MdModel.prepare_database()
    return temp_db

@pytest.fixture
def main_window(qtbot, mock_database):
    """Main window fixture with mocked database"""
    from Modan2 import ModanMainWindow
    window = ModanMainWindow()
    qtbot.addWidget(window)
    window.show()
    qtbot.waitForWindowShown(window)
    return window
```

---

## 3. 실행 단계 (6단계)

### Phase 1: 테스트 안전망 구축 (1-2주)

#### 단계 1.1: 기본 UI 테스트 작성
**목적**: 리팩토링 전 현재 동작을 보장하는 테스트 스위트 구축

**작업 내용**:
1. `tests/test_ui_basic.py` 생성
```python
import pytest
from PyQt5.QtCore import Qt
from PyQt5.QtTest import QTest

class TestMainWindow:
    def test_window_creation(self, main_window):
        """메인 윈도우가 정상적으로 생성되는지 확인"""
        assert main_window is not None
        assert main_window.isVisible()

    def test_initial_state(self, main_window):
        """초기 상태에서 버튼들이 올바르게 비활성화되어 있는지 확인"""
        assert not main_window.action_new_object.isEnabled()
        assert not main_window.action_analysis.isEnabled()

    def test_dataset_selection_enables_actions(self, qtbot, main_window):
        """데이터셋 선택 시 관련 액션이 활성화되는지 확인"""
        # 테스트 데이터셋 생성
        test_dataset = create_test_dataset()

        # 트리뷰에서 데이터셋 선택 시뮬레이션
        main_window.tree_view.setCurrentItem(test_dataset)

        # 액션 활성화 확인
        assert main_window.action_new_object.isEnabled()
        assert main_window.action_analysis.isEnabled()
```

2. `tests/test_ui_dialogs.py` 생성
```python
class TestDialogs:
    def test_new_dataset_dialog(self, qtbot, main_window):
        """새 데이터셋 다이얼로그 테스트"""
        with qtbot.waitSignal(main_window.dataset_created, timeout=1000):
            main_window.on_action_new_dataset()
            # 다이얼로그 입력 시뮬레이션
            dialog = main_window.findChild(NewDatasetDialog)
            dialog.name_input.setText("Test Dataset")
            dialog.accept()

    def test_preferences_dialog(self, qtbot, main_window):
        """환경설정 다이얼로그 테스트"""
        main_window.on_action_preferences()
        dialog = main_window.findChild(PreferencesDialog)

        # 설정 변경
        original_size = main_window.toolbar.iconSize()
        dialog.icon_size_slider.setValue(48)
        dialog.accept()

        # 변경사항 적용 확인
        assert main_window.toolbar.iconSize().width() == 48
```

**검증 방법**:
- `pytest tests/test_ui_*.py -v`
- 실제 앱 실행하여 테스트한 기능들 수동 확인

#### 단계 1.2: 핵심 워크플로우 테스트
**목적**: 사용자의 주요 사용 시나리오를 테스트로 구현

**작업 내용**:
1. `tests/test_workflows.py` 생성
```python
class TestCoreWorkflows:
    @pytest.fixture
    def sample_tps_file(self, tmp_path):
        """테스트용 TPS 파일 생성"""
        tps_path = tmp_path / "test.tps"
        tps_path.write_text(SAMPLE_TPS_CONTENT)
        return str(tps_path)

    def test_import_2d_landmark_workflow(self, qtbot, main_window, sample_tps_file):
        """2D 랜드마크 파일 가져오기 전체 워크플로우"""
        # 1. 새 데이터셋 생성
        dataset = create_dataset(main_window, "2D Test")

        # 2. TPS 파일 드래그앤드롭 시뮬레이션
        mime_data = create_file_mime_data([sample_tps_file])
        drop_event = create_drop_event(mime_data)
        main_window.table_view.dropEvent(drop_event)

        # 3. 객체가 테이블에 추가되었는지 확인
        assert main_window.table_view.model().rowCount() == 1

        # 4. 객체 선택 시 뷰어에 표시되는지 확인
        main_window.table_view.selectRow(0)
        assert main_window.viewer_2d.has_landmarks()

    @pytest.mark.slow
    def test_pca_analysis_workflow(self, qtbot, main_window, mock_analysis):
        """PCA 분석 실행 워크플로우 (분석 로직은 모킹)"""
        # 데이터셋과 객체 준비
        dataset = create_dataset_with_objects(main_window, n_objects=5)

        # 분석 실행
        with mock_analysis:
            main_window.on_action_analysis()
            dialog = main_window.findChild(AnalysisDialog)
            dialog.analysis_type.setCurrentText("PCA")
            dialog.accept()

        # 결과 확인
        assert dataset.child_count() == 1  # 분석 결과 추가됨
        assert "PCA" in dataset.child(0).text()
```

**검증 방법**:
- 각 워크플로우 테스트 개별 실행
- 코드 커버리지 확인: `pytest --cov=Modan2 tests/test_workflows.py`

---

### Phase 2: 애플리케이션 구조 분리 (1주)

#### 단계 2.1: 진입점 분리
**목적**: 테스트와 실제 실행 환경 분리, 의존성 주입 가능하도록 구조 개선

**작업 내용**:
1. `main.py` 생성
```python
#!/usr/bin/env python
"""
Modan2 - Morphometric Data Analysis Application
Main entry point for the application
"""
import sys
import argparse
from pathlib import Path

def parse_arguments():
    """커맨드라인 인자 파싱"""
    parser = argparse.ArgumentParser(description='Modan2 - Morphometric Data Analysis')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--db', type=str, help='Database file path')
    parser.add_argument('--config', type=str, help='Configuration file path')
    parser.add_argument('--lang', type=str, choices=['en', 'ko'], help='UI language')
    return parser.parse_args()

def main():
    """메인 실행 함수"""
    args = parse_arguments()

    # Qt 애플리케이션 초기화
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtCore import Qt

    # High DPI 지원
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

    app = QApplication(sys.argv)

    # 애플리케이션 설정
    from MdAppSetup import ApplicationSetup
    setup = ApplicationSetup(
        debug=args.debug,
        db_path=args.db,
        config_path=args.config,
        language=args.lang
    )
    setup.initialize()

    # 메인 윈도우 생성 및 표시
    from Modan2 import ModanMainWindow
    window = ModanMainWindow(setup.get_config())
    window.show()

    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
```

2. `MdAppSetup.py` 생성
```python
"""
Application setup and initialization module
"""
import os
import json
import logging
from pathlib import Path
from typing import Dict, Any, Optional

import MdModel
import MdUtils as mu

class ApplicationSetup:
    """애플리케이션 초기화 및 설정 관리"""

    def __init__(self, debug: bool = False, db_path: Optional[str] = None,
                 config_path: Optional[str] = None, language: Optional[str] = None):
        self.debug = debug
        self.db_path = db_path or self._get_default_db_path()
        self.config_path = config_path or self._get_default_config_path()
        self.language = language
        self.config: Dict[str, Any] = {}

        # 로깅 설정
        self._setup_logging()

    def _setup_logging(self):
        """로깅 설정"""
        level = logging.DEBUG if self.debug else logging.INFO
        logging.basicConfig(
            level=level,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def _get_default_db_path(self) -> str:
        """기본 데이터베이스 경로 반환"""
        app_dir = Path.home() / '.modan2'
        app_dir.mkdir(exist_ok=True)
        return str(app_dir / 'modan2.db')

    def _get_default_config_path(self) -> str:
        """기본 설정 파일 경로 반환"""
        app_dir = Path.home() / '.modan2'
        return str(app_dir / 'config.json')

    def initialize(self):
        """애플리케이션 초기화"""
        self.logger.info("Initializing Modan2 application...")

        # 1. 데이터베이스 준비
        self._prepare_database()

        # 2. 설정 로드
        self._load_settings()

        # 3. 번역 파일 로드
        self._load_translations()

        # 4. 플러그인 로드 (향후 확장)
        self._load_plugins()

        self.logger.info("Application initialized successfully")

    def _prepare_database(self):
        """데이터베이스 초기화 및 마이그레이션"""
        self.logger.debug(f"Preparing database at: {self.db_path}")
        MdModel.DATABASE_PATH = self.db_path
        MdModel.prepare_database()

    def _load_settings(self):
        """설정 파일 로드"""
        if Path(self.config_path).exists():
            with open(self.config_path, 'r') as f:
                self.config = json.load(f)
        else:
            self.config = self._get_default_config()
            self._save_settings()

    def _get_default_config(self) -> Dict[str, Any]:
        """기본 설정 반환"""
        return {
            'language': self.language or 'en',
            'theme': 'default',
            'toolbar_icon_size': 32,
            'auto_save': True,
            'recent_files': [],
            'window_geometry': None,
            'landmark_size': 2,
            'landmark_color': '#ff0000',
            'wireframe_color': '#0000ff',
            'background_color': '#ffffff',
        }

    def _save_settings(self):
        """설정 파일 저장"""
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)

    def _load_translations(self):
        """번역 파일 로드"""
        from PyQt5.QtCore import QTranslator, QLocale
        from PyQt5.QtWidgets import QApplication

        if self.config.get('language') == 'ko':
            translator = QTranslator()
            translator.load('translations/Modan2_ko.qm')
            QApplication.instance().installTranslator(translator)

    def _load_plugins(self):
        """플러그인 로드 (향후 확장용)"""
        pass

    def get_config(self) -> Dict[str, Any]:
        """현재 설정 반환"""
        return self.config
```

3. `Modan2.py` 수정
```python
# 기존 main 블록 제거하고 import 가능한 모듈로만 유지
# if __name__ == "__main__": 블록 완전 제거

# ModanMainWindow.__init__ 수정
class ModanMainWindow(QMainWindow):
    def __init__(self, config=None):
        super().__init__()
        self.config = config or {}
        self.initUI()
        self.apply_config()

    def apply_config(self):
        """설정 적용"""
        if 'toolbar_icon_size' in self.config:
            size = self.config['toolbar_icon_size']
            self.toolbar.setIconSize(QSize(size, size))

        if 'window_geometry' in self.config:
            # 저장된 윈도우 위치와 크기 복원
            self.restoreGeometry(self.config['window_geometry'])
```

**검증 방법**:
- 새로운 진입점으로 앱 실행: `python main.py`
- 커맨드라인 옵션 테스트: `python main.py --debug --lang ko`
- 기존 테스트 모두 통과 확인

---

### Phase 3: MVC 패턴 적용 (2-3주)

#### 단계 3.1: 컨트롤러 레이어 도입
**목적**: 비즈니스 로직을 UI에서 분리하여 테스트 가능성과 재사용성 향상

**작업 내용**:
1. `ModanController.py` 생성
```python
"""
Controller layer for Modan2 application
Handles business logic and coordinates between View and Model
"""
import logging
from typing import Optional, List, Dict, Any
from PyQt5.QtCore import QObject, pyqtSignal

import MdModel
import MdStatistics
import MdUtils as mu

class ModanController(QObject):
    """메인 컨트롤러 - 비즈니스 로직 처리"""

    # 시그널 정의 (View와의 통신용)
    dataset_created = pyqtSignal(object)  # MdDataset
    dataset_deleted = pyqtSignal(int)     # dataset_id
    object_added = pyqtSignal(object)     # MdObject
    analysis_completed = pyqtSignal(object)  # MdAnalysis
    error_occurred = pyqtSignal(str)      # error_message

    def __init__(self, view=None):
        super().__init__()
        self.view = view  # ModanMainWindow reference (optional for testing)
        self.logger = logging.getLogger(__name__)
        self.current_dataset: Optional[MdModel.MdDataset] = None
        self.current_object: Optional[MdModel.MdObject] = None

    # ========== Dataset Operations ==========

    def create_dataset(self, name: str, desc: str, dimension: int,
                      landmark_count: int, **kwargs) -> MdModel.MdDataset:
        """새 데이터셋 생성"""
        try:
            self.logger.info(f"Creating dataset: {name}")

            dataset = MdModel.MdDataset.create(
                dataset_name=name,
                dataset_desc=desc,
                dimension=dimension,
                landmark_count=landmark_count,
                **kwargs
            )

            self.dataset_created.emit(dataset)
            return dataset

        except Exception as e:
            self.logger.error(f"Failed to create dataset: {e}")
            self.error_occurred.emit(str(e))
            raise

    def delete_dataset(self, dataset_id: int) -> bool:
        """데이터셋 삭제"""
        try:
            self.logger.info(f"Deleting dataset: {dataset_id}")

            dataset = MdModel.MdDataset.get_by_id(dataset_id)
            dataset.delete_instance(recursive=True)

            self.dataset_deleted.emit(dataset_id)
            return True

        except Exception as e:
            self.logger.error(f"Failed to delete dataset: {e}")
            self.error_occurred.emit(str(e))
            return False

    def set_current_dataset(self, dataset: MdModel.MdDataset):
        """현재 작업 중인 데이터셋 설정"""
        self.current_dataset = dataset
        self.logger.debug(f"Current dataset set to: {dataset.dataset_name}")

    # ========== Object Operations ==========

    def import_objects(self, file_paths: List[str]) -> List[MdModel.MdObject]:
        """파일에서 객체 가져오기"""
        if not self.current_dataset:
            raise ValueError("No dataset selected")

        imported_objects = []

        for file_path in file_paths:
            try:
                self.logger.info(f"Importing object from: {file_path}")

                # 파일 타입에 따른 처리
                if file_path.lower().endswith(('.tps', '.nts')):
                    objects = self._import_landmark_file(file_path)
                elif file_path.lower().endswith(('.jpg', '.jpeg', '.png')):
                    objects = [self._import_image_file(file_path)]
                elif file_path.lower().endswith(('.obj', '.ply', '.stl')):
                    objects = [self._import_3d_file(file_path)]
                else:
                    self.logger.warning(f"Unsupported file type: {file_path}")
                    continue

                for obj in objects:
                    self.object_added.emit(obj)
                    imported_objects.append(obj)

            except Exception as e:
                self.logger.error(f"Failed to import {file_path}: {e}")
                self.error_occurred.emit(f"Failed to import {file_path}: {str(e)}")

        return imported_objects

    def _import_landmark_file(self, file_path: str) -> List[MdModel.MdObject]:
        """랜드마크 파일 가져오기"""
        # TPS/NTS 파일 파싱 로직
        landmarks_data = mu.read_landmark_file(file_path)
        objects = []

        for idx, landmarks in enumerate(landmarks_data):
            obj = MdModel.MdObject.create(
                dataset=self.current_dataset,
                object_name=f"{Path(file_path).stem}_{idx+1}",
                landmarks=landmarks
            )
            objects.append(obj)

        return objects

    def _import_image_file(self, file_path: str) -> MdModel.MdObject:
        """이미지 파일 가져오기"""
        image = MdModel.MdImage.create(
            file_path=file_path,
            dataset=self.current_dataset
        )

        obj = MdModel.MdObject.create(
            dataset=self.current_dataset,
            object_name=Path(file_path).stem,
            image=image
        )

        return obj

    def _import_3d_file(self, file_path: str) -> MdModel.MdObject:
        """3D 모델 파일 가져오기"""
        # STL/PLY를 OBJ로 변환
        obj_path = mu.process_3d_file(file_path)

        model_3d = MdModel.MdThreeDModel.create(
            file_path=obj_path,
            dataset=self.current_dataset
        )

        obj = MdModel.MdObject.create(
            dataset=self.current_dataset,
            object_name=Path(file_path).stem,
            model_3d=model_3d
        )

        return obj

    # ========== Analysis Operations ==========

    def run_analysis(self, analysis_type: str, params: Dict[str, Any]) -> MdModel.MdAnalysis:
        """분석 실행"""
        if not self.current_dataset:
            raise ValueError("No dataset selected")

        try:
            self.logger.info(f"Running {analysis_type} analysis")

            # 분석 타입별 처리
            if analysis_type == "PCA":
                result = self._run_pca(params)
            elif analysis_type == "CVA":
                result = self._run_cva(params)
            elif analysis_type == "MANOVA":
                result = self._run_manova(params)
            else:
                raise ValueError(f"Unknown analysis type: {analysis_type}")

            # 결과 저장
            analysis = MdModel.MdAnalysis.create(
                dataset=self.current_dataset,
                analysis_type=analysis_type,
                parameters=params,
                results=result
            )

            self.analysis_completed.emit(analysis)
            return analysis

        except Exception as e:
            self.logger.error(f"Analysis failed: {e}")
            self.error_occurred.emit(str(e))
            raise

    def _run_pca(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """PCA 분석 실행"""
        objects = self.current_dataset.get_objects()
        landmarks = [obj.get_landmarks() for obj in objects]

        pca_result = MdStatistics.perform_pca(
            landmarks,
            n_components=params.get('n_components', None)
        )

        return pca_result

    def _run_cva(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """CVA 분석 실행"""
        # CVA 로직 구현
        pass

    def _run_manova(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """MANOVA 분석 실행"""
        # MANOVA 로직 구현
        pass
```

2. `Modan2.py` 리팩토링
```python
# 이벤트 핸들러를 컨트롤러 호출로 변경
class ModanMainWindow(QMainWindow):
    def __init__(self, config=None):
        super().__init__()
        self.config = config or {}
        self.controller = ModanController(self)
        self._setup_controller_connections()
        self.initUI()

    def _setup_controller_connections(self):
        """컨트롤러 시그널 연결"""
        self.controller.dataset_created.connect(self.on_dataset_created)
        self.controller.dataset_deleted.connect(self.on_dataset_deleted)
        self.controller.object_added.connect(self.on_object_added)
        self.controller.analysis_completed.connect(self.on_analysis_completed)
        self.controller.error_occurred.connect(self.show_error_message)

    def on_action_new_dataset(self):
        """새 데이터셋 액션 - 컨트롤러에 위임"""
        dialog = NewDatasetDialog(self)
        if dialog.exec_():
            params = dialog.get_parameters()
            self.controller.create_dataset(**params)

    def on_action_analysis(self):
        """분석 실행 액션 - 컨트롤러에 위임"""
        if not self.controller.current_dataset:
            QMessageBox.warning(self, "Warning", "Please select a dataset first")
            return

        dialog = AnalysisDialog(self)
        if dialog.exec_():
            analysis_type = dialog.get_analysis_type()
            params = dialog.get_parameters()

            # 프로그레스 다이얼로그 표시
            progress = QProgressDialog("Running analysis...", "Cancel", 0, 0, self)
            progress.setWindowModality(Qt.WindowModal)
            progress.show()

            try:
                self.controller.run_analysis(analysis_type, params)
            finally:
                progress.close()

    def dropEvent(self, event):
        """드래그앤드롭 이벤트 - 컨트롤러에 위임"""
        if event.mimeData().hasUrls():
            file_paths = [url.toLocalFile() for url in event.mimeData().urls()]
            self.controller.import_objects(file_paths)
            event.accept()
```

**검증 방법**:
- 컨트롤러 단위 테스트 작성 및 실행
- UI와 컨트롤러 통합 테스트
- 기존 기능 동작 확인

#### 단계 3.2: 뷰 컴포넌트 분리
**목적**: UI 컴포넌트를 재사용 가능한 위젯으로 분리

**작업 내용**:
1. `ModanWidgets.py` 생성
```python
"""
Custom widgets for Modan2 application
"""
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

class DatasetTreeWidget(QTreeWidget):
    """데이터셋 트리 위젯"""

    dataset_selected = pyqtSignal(object)
    analysis_selected = pyqtSignal(object)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._setup_connections()

    def _setup_ui(self):
        """UI 설정"""
        self.setHeaderLabels(['Datasets', 'Objects', 'Type'])
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setAlternatingRowColors(True)

    def _setup_connections(self):
        """시그널 연결"""
        self.itemSelectionChanged.connect(self._on_selection_changed)
        self.customContextMenuRequested.connect(self._show_context_menu)

    def add_dataset(self, dataset):
        """데이터셋 추가"""
        item = QTreeWidgetItem(self)
        item.setText(0, dataset.dataset_name)
        item.setText(1, str(dataset.object_count))
        item.setText(2, f"{dataset.dimension}D")
        item.setData(0, Qt.UserRole, dataset)

        # 아이콘 설정
        icon = QIcon('icons/M2Dataset2D_3.png' if dataset.dimension == 2
                    else 'icons/M2Dataset3D_4.png')
        item.setIcon(0, icon)

        return item

    def add_analysis(self, parent_item, analysis):
        """분석 결과 추가"""
        item = QTreeWidgetItem(parent_item)
        item.setText(0, f"{analysis.analysis_type} Analysis")
        item.setText(1, analysis.created_at.strftime("%Y-%m-%d %H:%M"))
        item.setData(0, Qt.UserRole, analysis)

        # 아이콘 설정
        item.setIcon(0, QIcon('icons/M2Analysis_1.png'))

        return item

    def _on_selection_changed(self):
        """선택 변경 처리"""
        items = self.selectedItems()
        if items:
            data = items[0].data(0, Qt.UserRole)
            if isinstance(data, MdModel.MdDataset):
                self.dataset_selected.emit(data)
            elif isinstance(data, MdModel.MdAnalysis):
                self.analysis_selected.emit(data)

    def _show_context_menu(self, position):
        """컨텍스트 메뉴 표시"""
        item = self.itemAt(position)
        if not item:
            return

        menu = QMenu(self)
        data = item.data(0, Qt.UserRole)

        if isinstance(data, MdModel.MdDataset):
            menu.addAction("Edit Dataset", lambda: self.edit_dataset(data))
            menu.addAction("Delete Dataset", lambda: self.delete_dataset(data))
            menu.addSeparator()
            menu.addAction("Export Dataset", lambda: self.export_dataset(data))
        elif isinstance(data, MdModel.MdAnalysis):
            menu.addAction("View Results", lambda: self.view_analysis(data))
            menu.addAction("Export Results", lambda: self.export_analysis(data))
            menu.addAction("Delete Analysis", lambda: self.delete_analysis(data))

        menu.exec_(self.mapToGlobal(position))


class ObjectTableWidget(QTableWidget):
    """객체 테이블 위젯"""

    object_selected = pyqtSignal(object)
    objects_dropped = pyqtSignal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._setup_drag_drop()

    def _setup_ui(self):
        """UI 설정"""
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setSortingEnabled(True)
        self.setContextMenuPolicy(Qt.CustomContextMenu)

        # 컬럼 설정
        self.setColumnCount(5)
        self.setHorizontalHeaderLabels(['Name', 'Type', 'Landmarks', 'Size', 'Modified'])

        # 컬럼 너비 조정
        header = self.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)

    def _setup_drag_drop(self):
        """드래그앤드롭 설정"""
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.DropOnly)

    def add_object(self, obj):
        """객체 추가"""
        row = self.rowCount()
        self.insertRow(row)

        # 이름
        self.setItem(row, 0, QTableWidgetItem(obj.object_name))

        # 타입
        obj_type = "Image" if obj.image else "3D Model" if obj.model_3d else "Landmarks"
        self.setItem(row, 1, QTableWidgetItem(obj_type))

        # 랜드마크 수
        landmark_count = len(obj.landmarks) if obj.landmarks else 0
        self.setItem(row, 2, QTableWidgetItem(str(landmark_count)))

        # 크기
        size_text = self._get_object_size(obj)
        self.setItem(row, 3, QTableWidgetItem(size_text))

        # 수정 시간
        self.setItem(row, 4, QTableWidgetItem(obj.modified_at.strftime("%Y-%m-%d %H:%M")))

        # 사용자 데이터 저장
        self.item(row, 0).setData(Qt.UserRole, obj)

    def _get_object_size(self, obj):
        """객체 크기 텍스트 반환"""
        if obj.image:
            return f"{obj.image.width}x{obj.image.height}"
        elif obj.model_3d:
            return f"{obj.model_3d.vertex_count} vertices"
        else:
            return "-"

    def dragEnterEvent(self, event):
        """드래그 진입 이벤트"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        """드롭 이벤트"""
        if event.mimeData().hasUrls():
            urls = [url.toLocalFile() for url in event.mimeData().urls()]
            self.objects_dropped.emit(urls)
            event.acceptProposedAction()
```

2. `Modan2.py` 리팩토링 - UI 생성 코드 정리
```python
class ModanMainWindow(QMainWindow):
    def initUI(self):
        """UI 초기화 - 간소화된 버전"""
        self.setWindowTitle('Modan2')
        self.setGeometry(100, 100, 1200, 800)

        # 중앙 위젯 설정
        self._create_central_widget()

        # 메뉴바, 툴바, 상태바
        self._create_menus()
        self._create_toolbar()
        self._create_statusbar()

        # 독 위젯
        self._create_dock_widgets()

    def _create_central_widget(self):
        """중앙 위젯 생성"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # 레이아웃
        layout = QVBoxLayout(central_widget)

        # 탭 위젯
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)

        # 2D 뷰어 탭
        self.viewer_2d = Viewer2D()
        self.tab_widget.addTab(self.viewer_2d, "2D View")

        # 3D 뷰어 탭
        self.viewer_3d = Viewer3D()
        self.tab_widget.addTab(self.viewer_3d, "3D View")

    def _create_menus(self):
        """메뉴바 생성"""
        menubar = self.menuBar()

        # File 메뉴
        file_menu = menubar.addMenu('&File')
        self._add_file_menu_actions(file_menu)

        # Edit 메뉴
        edit_menu = menubar.addMenu('&Edit')
        self._add_edit_menu_actions(edit_menu)

        # Analysis 메뉴
        analysis_menu = menubar.addMenu('&Analysis')
        self._add_analysis_menu_actions(analysis_menu)

        # Help 메뉴
        help_menu = menubar.addMenu('&Help')
        self._add_help_menu_actions(help_menu)

    def _create_toolbar(self):
        """툴바 생성"""
        self.toolbar = self.addToolBar('Main')
        self.toolbar.setMovable(False)

        # 툴바 액션 추가
        self.toolbar.addAction(self.action_new_dataset)
        self.toolbar.addAction(self.action_new_object)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.action_import)
        self.toolbar.addAction(self.action_export)
        self.toolbar.addSeparator()
        self.toolbar.addAction(self.action_analysis)

        # 아이콘 크기 설정
        size = self.config.get('toolbar_icon_size', 32)
        self.toolbar.setIconSize(QSize(size, size))

    def _create_dock_widgets(self):
        """독 위젯 생성"""
        # 데이터셋 트리 독
        self.dataset_dock = QDockWidget("Datasets", self)
        self.dataset_tree = DatasetTreeWidget()
        self.dataset_dock.setWidget(self.dataset_tree)
        self.addDockWidget(Qt.LeftDockWidgetArea, self.dataset_dock)

        # 객체 테이블 독
        self.object_dock = QDockWidget("Objects", self)
        self.object_table = ObjectTableWidget()
        self.object_dock.setWidget(self.object_table)
        self.addDockWidget(Qt.BottomDockWidgetArea, self.object_dock)

        # 시그널 연결
        self.dataset_tree.dataset_selected.connect(self.on_dataset_selected)
        self.object_table.object_selected.connect(self.on_object_selected)
        self.object_table.objects_dropped.connect(self.controller.import_objects)
```

**검증 방법**:
- 각 위젯 개별 테스트
- 전체 UI 통합 테스트
- 시각적 검증

---

### Phase 4: 상수 및 유틸리티 정리 (3일)

#### 단계 4.1: 상수 분리
**작업 내용**:
1. `MdConstants.py` 생성
```python
"""
Constants and configuration values for Modan2
"""
from pathlib import Path

# 애플리케이션 정보
APP_NAME = "Modan2"
APP_VERSION = "0.1.4"
APP_AUTHOR = "Your Name"
APP_LICENSE = "MIT"

# 경로 설정
BASE_DIR = Path(__file__).parent
ICONS_DIR = BASE_DIR / "icons"
TRANSLATIONS_DIR = BASE_DIR / "translations"

# 아이콘 매핑
ICONS = {
    'new_dataset': str(ICONS_DIR / 'M2NewDataset_1.png'),
    'new_object': str(ICONS_DIR / 'M2NewObject_2.png'),
    'import': str(ICONS_DIR / 'M2Import_1.png'),
    'export': str(ICONS_DIR / 'M2Export_1.png'),
    'analysis': str(ICONS_DIR / 'M2Analysis_1.png'),
    'preferences': str(ICONS_DIR / 'M2Preferences_1.png'),
    'about': str(ICONS_DIR / 'M2About_1.png'),
    'landmark': str(ICONS_DIR / 'M2Landmark_2.png'),
    'wireframe': str(ICONS_DIR / 'M2Wireframe_2.png'),
    'calibration': str(ICONS_DIR / 'M2Calibration_2.png'),
    'dataset_2d': str(ICONS_DIR / 'M2Dataset2D_3.png'),
    'dataset_3d': str(ICONS_DIR / 'M2Dataset3D_4.png'),
}

# 파일 필터
FILE_FILTERS = {
    'landmark': "Landmark Files (*.tps *.nts *.txt);;TPS Files (*.tps);;NTS Files (*.nts)",
    'image': "Image Files (*.jpg *.jpeg *.png *.bmp *.tiff);;All Files (*.*)",
    '3d_model': "3D Model Files (*.obj *.ply *.stl);;OBJ Files (*.obj);;PLY Files (*.ply);;STL Files (*.stl)",
    'all': "All Supported Files (*.tps *.nts *.txt *.jpg *.jpeg *.png *.obj *.ply *.stl)",
}

# 기본 설정값
DEFAULT_SETTINGS = {
    'language': 'en',
    'theme': 'default',
    'toolbar_icon_size': 32,
    'auto_save': True,
    'auto_save_interval': 300,  # seconds
    'max_recent_files': 10,
    'landmark_size': 2,
    'landmark_color': '#ff0000',
    'wireframe_color': '#0000ff',
    'background_color': '#ffffff',
    'selection_color': '#00ff00',
    'hover_color': '#ffff00',
}

# 분석 타입
ANALYSIS_TYPES = [
    'PCA',
    'CVA',
    'MANOVA',
    'Procrustes',
    'ThinPlateSpline',
]

# 에러 메시지
ERROR_MESSAGES = {
    'no_dataset': "Please select or create a dataset first.",
    'no_object': "Please select an object first.",
    'invalid_file': "The selected file is not valid or corrupted.",
    'insufficient_objects': "Insufficient objects for analysis. At least {} objects required.",
    'analysis_failed': "Analysis failed: {}",
    'save_failed': "Failed to save: {}",
    'load_failed': "Failed to load: {}",
}
```

#### 단계 4.2: 헬퍼 함수 정리
**작업 내용**:
1. `MdHelpers.py` 생성
```python
"""
Helper functions and utilities for Modan2
"""
import os
import json
import hashlib
from typing import Any, Dict, List, Optional
from pathlib import Path
from PyQt5.QtWidgets import QMessageBox, QFileDialog

def show_message(parent, title: str, message: str,
                message_type: str = 'info') -> None:
    """메시지 박스 표시"""
    if message_type == 'info':
        QMessageBox.information(parent, title, message)
    elif message_type == 'warning':
        QMessageBox.warning(parent, title, message)
    elif message_type == 'error':
        QMessageBox.critical(parent, title, message)
    elif message_type == 'question':
        return QMessageBox.question(parent, title, message)

def get_open_file_name(parent, title: str, filter: str,
                       start_dir: str = '') -> Optional[str]:
    """파일 열기 다이얼로그"""
    file_name, _ = QFileDialog.getOpenFileName(
        parent, title, start_dir, filter
    )
    return file_name if file_name else None

def get_save_file_name(parent, title: str, filter: str,
                      start_dir: str = '') -> Optional[str]:
    """파일 저장 다이얼로그"""
    file_name, _ = QFileDialog.getSaveFileName(
        parent, title, start_dir, filter
    )
    return file_name if file_name else None

def get_directory(parent, title: str, start_dir: str = '') -> Optional[str]:
    """디렉토리 선택 다이얼로그"""
    dir_name = QFileDialog.getExistingDirectory(
        parent, title, start_dir
    )
    return dir_name if dir_name else None

def calculate_file_hash(file_path: str, algorithm: str = 'md5') -> str:
    """파일 해시 계산"""
    hash_func = hashlib.new(algorithm)
    with open(file_path, 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b''):
            hash_func.update(chunk)
    return hash_func.hexdigest()

def format_file_size(size_bytes: int) -> str:
    """파일 크기 포맷팅"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} PB"

def load_json_file(file_path: str) -> Dict[str, Any]:
    """JSON 파일 로드"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_json_file(file_path: str, data: Dict[str, Any],
                  indent: int = 2) -> None:
    """JSON 파일 저장"""
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=indent, ensure_ascii=False)

def ensure_directory(path: str) -> None:
    """디렉토리 존재 확인 및 생성"""
    Path(path).mkdir(parents=True, exist_ok=True)

def get_timestamp_string() -> str:
    """타임스탬프 문자열 생성"""
    from datetime import datetime
    return datetime.now().strftime("%Y%m%d_%H%M%S")
```

---

### Phase 5: 테스트 커버리지 확대 (1주)

#### 단계 5.1: 컨트롤러 테스트
**작업 내용**:
1. `tests/test_controller.py` 생성
```python
import pytest
from unittest.mock import Mock, MagicMock, patch
from ModanController import ModanController

class TestModanController:
    @pytest.fixture
    def controller(self):
        """컨트롤러 픽스처"""
        controller = ModanController()
        return controller

    def test_create_dataset(self, controller):
        """데이터셋 생성 테스트"""
        with patch('MdModel.MdDataset.create') as mock_create:
            mock_dataset = Mock()
            mock_dataset.dataset_name = "Test Dataset"
            mock_create.return_value = mock_dataset

            result = controller.create_dataset(
                name="Test Dataset",
                desc="Test Description",
                dimension=2,
                landmark_count=10
            )

            assert result == mock_dataset
            mock_create.assert_called_once()

    def test_import_objects_without_dataset(self, controller):
        """데이터셋 없이 객체 가져오기 시도"""
        controller.current_dataset = None

        with pytest.raises(ValueError, match="No dataset selected"):
            controller.import_objects(["test.tps"])

    def test_run_pca_analysis(self, controller):
        """PCA 분석 실행 테스트"""
        # Mock 설정
        mock_dataset = Mock()
        mock_objects = [Mock(), Mock(), Mock()]
        mock_dataset.get_objects.return_value = mock_objects
        controller.current_dataset = mock_dataset

        with patch('MdStatistics.perform_pca') as mock_pca:
            mock_pca.return_value = {'components': [1, 2, 3]}

            result = controller.run_analysis('PCA', {'n_components': 3})

            mock_pca.assert_called_once()
            assert 'components' in result.results
```

#### 단계 5.2: 통합 테스트
**작업 내용**:
1. `tests/test_integration.py` 생성
```python
import pytest
from PyQt5.QtCore import Qt
from PyQt5.QtTest import QTest

class TestIntegration:
    def test_full_workflow(self, qtbot, main_window, temp_db):
        """전체 워크플로우 통합 테스트"""
        # 1. 데이터셋 생성
        qtbot.mouseClick(main_window.action_new_dataset, Qt.LeftButton)
        dialog = main_window.findChild(NewDatasetDialog)
        dialog.name_input.setText("Integration Test Dataset")
        dialog.dimension_combo.setCurrentText("2D")
        dialog.landmark_spin.setValue(20)
        qtbot.mouseClick(dialog.ok_button, Qt.LeftButton)

        # 2. 데이터셋이 트리에 추가되었는지 확인
        assert main_window.dataset_tree.topLevelItemCount() == 1

        # 3. 파일 가져오기
        sample_file = create_sample_tps_file()
        main_window.controller.import_objects([sample_file])

        # 4. 객체가 테이블에 추가되었는지 확인
        assert main_window.object_table.rowCount() > 0

        # 5. 분석 실행
        qtbot.mouseClick(main_window.action_analysis, Qt.LeftButton)
        dialog = main_window.findChild(AnalysisDialog)
        dialog.analysis_combo.setCurrentText("PCA")
        qtbot.mouseClick(dialog.run_button, Qt.LeftButton)

        # 6. 분석 결과가 트리에 추가되었는지 확인
        dataset_item = main_window.dataset_tree.topLevelItem(0)
        assert dataset_item.childCount() == 1
```

---

### Phase 6: 문서화 및 마무리 (3일)

#### 단계 6.1: 개발자 문서 작성
1. `docs/ARCHITECTURE.md` - 아키텍처 설명
2. `docs/TESTING.md` - 테스트 가이드
3. `docs/CONTRIBUTING.md` - 기여 가이드

#### 단계 6.2: 성능 최적화
1. 프로파일링 및 병목 지점 파악
2. 데이터베이스 쿼리 최적화
3. UI 렌더링 최적화

---

## 4. 검증 체크리스트

### 각 단계별 검증 항목

#### ✅ Phase 1 완료 조건
- [ ] 메인 윈도우 생성 테스트 통과
- [ ] 초기 상태 테스트 통과
- [ ] 데이터셋 선택 테스트 통과
- [ ] 다이얼로그 테스트 통과
- [ ] 코드 커버리지 30% 이상

#### ✅ Phase 2 완료 조건
- [ ] `python main.py`로 앱 실행 가능
- [ ] 커맨드라인 옵션 동작
- [ ] 설정 파일 로드/저장 동작
- [ ] 기존 테스트 모두 통과

#### ✅ Phase 3 완료 조건
- [ ] 컨트롤러 단위 테스트 통과
- [ ] UI-컨트롤러 통합 동작
- [ ] 모든 이벤트 핸들러 리팩토링 완료
- [ ] 코드 커버리지 50% 이상

#### ✅ Phase 4 완료 조건
- [ ] 상수 파일 분리 완료
- [ ] 헬퍼 함수 정리 완료
- [ ] import 정리 완료

#### ✅ Phase 5 완료 조건
- [ ] 컨트롤러 테스트 커버리지 80% 이상
- [ ] 통합 테스트 시나리오 5개 이상
- [ ] 전체 코드 커버리지 60% 이상

#### ✅ Phase 6 완료 조건
- [ ] 문서화 완료
- [ ] 성능 벤치마크 수행
- [ ] 최종 회귀 테스트 통과

---

## 5. 리스크 관리

### 예상 리스크 및 대응 방안

1. **데이터베이스 마이그레이션 실패**
   - 대응: 백업 후 진행, 롤백 스크립트 준비

2. **Qt 이벤트 루프 관련 테스트 실패**
   - 대응: qtbot의 wait 메서드 활용, 비동기 테스트 패턴 적용

3. **성능 저하**
   - 대응: 프로파일링 도구 활용, 점진적 최적화

4. **의존성 충돌**
   - 대응: 가상환경 사용, requirements.txt 버전 고정

---

## 6. 타임라인

### 전체 일정 (약 6-8주)

```
Week 1-2: Phase 1 (테스트 안전망 구축)
Week 3:   Phase 2 (애플리케이션 구조 분리)
Week 4-5: Phase 3 (MVC 패턴 적용)
Week 6:   Phase 4 (상수 및 유틸리티 정리)
Week 7:   Phase 5 (테스트 커버리지 확대)
Week 8:   Phase 6 (문서화 및 마무리)
```

### 일일 작업 플로우

1. 오전: 코드 작성 및 리팩토링
2. 오후: 테스트 작성 및 실행
3. 저녁: 문서 업데이트 및 리뷰

---

## 7. 성공 지표

### 정량적 지표
- 코드 커버리지: 60% 이상
- 테스트 케이스: 100개 이상
- 파일당 코드 라인: 500줄 이하
- 사이클로매틱 복잡도: 10 이하

### 정성적 지표
- 새 기능 추가 시간 50% 단축
- 버그 발생률 70% 감소
- 코드 리뷰 시간 30% 단축
- 신규 개발자 온보딩 시간 50% 단축

---

## 8. 참고 자료

### 도구 및 라이브러리
- [pytest-qt Documentation](https://pytest-qt.readthedocs.io/)
- [PyQt5 Documentation](https://doc.qt.io/qtforpython/)
- [Python Testing Best Practices](https://realpython.com/pytest-python-testing/)

### 디자인 패턴
- [MVC Pattern in Python](https://realpython.com/the-model-view-controller-mvc-paradigm-summarized-with-legos/)
- [Repository Pattern](https://www.cosmicpython.com/book/chapter_02_repository.html)
- [Observer Pattern in Qt](https://doc.qt.io/qt-5/signalsandslots.html)

---

## 9. 결론

이 통합 계획은 Modan2 프로젝트의 코드 품질과 유지보수성을 크게 향상시킬 것입니다. 테스트 우선 접근과 점진적 리팩토링을 통해 안정성을 유지하면서 구조를 개선할 수 있습니다.

핵심은 **작게 시작하여 지속적으로 검증**하는 것입니다. 각 단계가 완료될 때마다 앱이 정상 동작하는지 확인하고, 테스트를 통해 회귀를 방지해야 합니다.

이 계획을 따르면 Modan2는 더 확장 가능하고, 테스트 가능하며, 유지보수가 쉬운 애플리케이션이 될 것입니다.
